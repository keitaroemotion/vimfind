#!/usr/bin/env ruby

require "colorize"

option = $*[0]

diff       = `git diff develop --name-only`
files = diff.split("\n")

puts "\n#{files.size.to_s.magenta} Files\n\n"

$files_all = files.freeze

def index
  print "\n[enter number: /all :t :e] "
  choice = $stdin.gets.chomp
  abort if choice.downcase == "q"
  choice.strip
end

$recollection_dir = "/usr/local/etc/ddff"

def recollect_last_test(test_file)
  system "mkdir -p #{$recollection_dir}"
  system "echo #{test_file} > #{$recollection_dir}/recollection" 
end

def testare(files, kw = "")
  files = files.select {|f| f.end_with?("_test.rb") }
  if files.size == 0
    puts "\n0 files found\n".red
    files = $files_all 
  end  

  if files.size == 1
    command = "bundle exec ruby -I test #{files[0]} --verbose"
    puts "command: #{command}".green
    recollect_last_test(files[0])
    system command
    abort
  end

  puts
  files.each_with_index do |tfile, i|
    puts "#{i}: #{gsubs(tfile, kw)}"
  end
  i = index
  return if extra_option_2(i)
  if i == ""
    p = `cat #{$recollection_dir}/recollection`
    testare [p.to_s.strip]
  elsif i == "all"
    files.each do |file|
      command = "bundle exec ruby -I test #{file} --verbose"
      puts "command: #{command}".green
      system command
    end
  elsif !/[^0-9]/.match(i).nil?  
    testare(files.select {|file| has?(file, i)}, i)
  else  
    file = files[i.to_i]
    command = "bundle exec ruby -I test #{file} --verbose"
    puts "command: #{command}".green
    recollect_last_test(file)
    system command
  end  
end

def has?(x, kws)
  kws = kws.split(" ")
  kws.select{|kw| x.include?(kw)}.size == kws.size
end

def extra_option(opt)
  opt = opt.strip
  if opt == ":t"
    testare $files_all
    return true
  elsif opt == ":e"
    puts "\nyou are already in the edit mode\n".magenta
    return false
  end
end    

def extra_option_2(opt)
  opt = opt.strip
  if opt == ":e"
    open_file "",  $files_all
    return true
  elsif opt == ":t"
    puts "\nyou are already in the test mode\n".magenta
    return false
  end
end    


def gsubs(x, kws)
  kws.split(" ").each do |kw|
    x = x.gsub(kw, kw.green)
  end
  x
end

def open_file(kws, files)
  alert = ""
  return if extra_option(kws)
  files = files.select{|x| has?(x, kws) } if !kws.nil?
  if files.size == 0
    alert = "\n\nnon found\n\n".red
    files = $files_all
  end
  files.each_with_index do |file, i|
    puts "#{i.to_s.cyan}: #{gsubs(file, kws)}"
  end
  print alert
  i = index
  return if extra_option(i)
  if !/^[0-9]/.match(i).nil? || files.size == 1
    system "vim #{files[i.to_i]}"
  else
    open_file i, files
  end
end

def cleansing_target_line(line, count)
  line = line.chomp
  if line.end_with?(" ")
    [line.rstrip, count + 1]
  else
    [line, count]
  end
end  

def grep(files)
  kw = ARGV[1]
  if kw.nil?
    print "[Enter Keyword: ] " 
    kw = $stdin.gets.chomp
  end
  files.each do |file|
    content = File.open(file, "r").each_line.to_a.join.downcase 
    if content.include?(kw.downcase)
      puts file.magenta
    end
  end
end

def clean(files)
  result = []
  files.each do |file|
    count = 0
    clean_text =
      File.open(file, "r").map do |line|
        line, count = cleansing_target_line(line, count)
        "#{line}\n"
      end.inject(:+)

    File.open(file, "w") do |f|
      f.puts clean_text
    end
    result.push [file, count]
  end
  result.each do |file, count|
    puts "#{file}: #{count.to_s.green}" if count > 0
  end
end

def find_branch(files, branches = [], kw = nil)
  if kw
    branches = branches.select{|x| x.include?(kw)}
  elsif branches.nil? || branches.size == 0
    branches = `git branch`.split("\n")
  end  
  branches.each_with_index do |br, i|
    puts "#{i.to_s.green} #{br}"
  end
  print "[from which?] "
  i = $stdin.gets.chomp
  if i.nil?
    return find_branch files, branches
  elsif /[^0-9]/.match(i)
    return find_branch(files, branches, i)
  else
    return branches[i.to_i]
  end
end

def transfer(targets, branch)
  targets.each do |file|
    puts "[#{file}]".cyan
  end

  print "okay? [y/n]: "
  option = $stdin.gets.chomp.downcase
  if option == "y"
    targets.each do |file|
      puts   "git co #{branch.strip} #{file.strip}".green
      system "git co #{branch} #{file}"
    end
  end
end

def get_large_files(files, branch, kw)
  if !kw
    puts "git diff --name-only #{branch}".green
    files = `git diff --name-only #{branch}`.split("\n").map do |file|
      file.strip 
    end
    kw = ""
  end  
  files = files.select {|x| x.include?(kw)}
  files
end

def sync(files, kw = nil, branch = nil)
  branch = find_branch(files).gsub("*", "").strip if branch.nil?
  files = get_large_files(files, branch, kw)
  files.each_with_index do |file, i|
   puts "#{i.to_s.magenta} #{file}"
  end
  print "Select files[ex. 0 2 3 4/all]: "
  i = $stdin.gets.chomp
  if i == "q"
    return
  elsif i.nil?
    return sync files, i, branch
  elsif i == "all"
   transfer(files, branch)
  elsif !/[^0-9\ ]/.match(i).nil?
    return sync(files, i, branch)
  else
   targets = i.split(" ").map{|x| files[x.to_i]}
   transfer(targets, branch)
  end
end

case option 
when "sync"
  sync files
when "g"
  grep files
when "t"
  testare files
when "/"
  open_file $*[1], files
when "//"
  system files.inject("vim"){ |acc, file| "#{acc} #{file}" } 
when "c"  
  clean files.select {|file| file.end_with?(".rb") } 
when "r"  
  files.select{|f| f.end_with?(".rb")}.each do |file|
    p = `rubocop #{file}`
    unless "#{p}".include? "no offense"
      system "rubocop #{file}"
      $stdin.gets.chomp
    end
  end
when "help", "-h", "--help"
  puts ""
  puts "sync      ... sync files"
  puts "c         ... clean"
  puts "g         ... grep"
  puts "t         ... test (ruby)"
  puts "r         ... rubocop"
  puts "/         ... open a file after reading it."
  puts "//         ... open all files after reading it."
  puts "help, -h ... help option"
  puts ""
else
  open_file $*[0..-1].join(" "), files
end
