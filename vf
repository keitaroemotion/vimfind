#!/usr/bin/env ruby
require 'colorize'

GREP = "w:"

def disp_instruction() abort "\nyou need argument.\n".red end

def add_test(arr)
  arr + arr.map {|a| "test/#{a}"}
end

terms =  ARGV.size > 0 ? ARGV : disp_instruction
mvc_mode = ARGV.include?("-mvc") ? add_test(["controllers","models","views", "backends"]) : []

def get_directory()
  ARGV.select {|arg| File.directory?(arg) }
end

directory = "#{get_directory[0]}**/*" 
terms = terms.select {|term| ![directory, "-mvc"].include?(term) }.map{ |arg| arg.downcase }

def file_open(file, mode)
  File.open(file, mode).read.downcase rescue ""
end

def get_words(terms)
  terms.select{|term| term.start_with?(GREP)}
    .map{|term| term.gsub(GREP,"")}
end

def get_non_words(terms)
  terms.select{|term| !term.start_with?(GREP)}
end

def has_words(terms, text)
  (terms.select{|term| text.include?(term)}.size == terms.size) \
    && (terms.size > 0)
end

def is_term_in_file(file, terms)
  has_words(terms, file_open(file, "r"))
end

def includes(file, terms, words_in_file_name=true, words_in_file_content=true)
  non_terms = get_non_words(terms) 
  terms     = get_words(terms)
  words_in_file_content =
    File.file?(file) && is_term_in_file(file, terms) if terms.size > 0
  words_in_file_name = non_terms.select{ |term|
                         file.downcase.include?(term)
                       }.size == non_terms.size if non_terms.size > 0
  words_in_file_name && words_in_file_content                      
end

def replace(text, terms)
  terms.each { |term| text = text.gsub(term, "#{term.green}") }
  text
end

def has(mvc, file, terms)
  if mvc.size > 0
    name = terms.select{|x| !x.include?("/") && !x.include?(GREP) }[0]
    mvc.map{|x| Regexp.new("#{x}/#{name}*") }.select{|x| x.match(file) }.size > 0
  else
    true
  end
end

def list_files(dir, terms, mvc)
  Dir.glob(dir).select{|file| includes(file, terms) }
    .select{ |file| has(mvc, file, terms) } 
end

def add_config_files(files)
  files.push "#{Dir.pwd}/db/schema.rb"
end

def display_matches(f, terms)
  File.open(f, "r").each_with_index do |item, index|
    print replace("#{item}", terms) if  has_words(terms, item) 
  end
end

def sort(files, i, new_files=[])
  files = files.flatten 
  [i-1..files.size-1].each {|x| new_files.push(files[x])}
  [0..i-2].each {|x| new_files.push(files[x])}
  new_files.flatten
end

def execute_files(files, mvc_keyword, terms, i=0)
  files.each_with_index do |f, index|
    if (!mvc_keyword || file_open(f, "r").include?(mvc_keyword))
      print "#{replace(f, terms)} ? [y/q/w/p]"
      input = $stdin.gets.chomp.downcase
      system "vim #{f}"             if input == "y"
      display_matches(f, key_terms) if input == "w"
      execute_files(sort(files, index), mvc_keyword, terms) if input == "p"
      abort                         if input == "q"
    end
  end
end

def search_all(terms, dir, mvc, mvc_keyword)
  key_terms = get_words(terms)
  execute_files list_files(dir, terms, mvc), mvc_keyword, terms
end

mvc_keyword = terms.select{|x| x.include?(GREP) }[0] 
mvc_keyword = mvc_keyword.gsub(GREP,"") if mvc_keyword 

search_all(terms, directory, mvc_mode, mvc_keyword) 

