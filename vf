#!/usr/bin/env ruby
require 'colorize'

GREP = "w:"

def disp_instruction() abort "\nyou need argument.\n".red end

def add_test(arr)
  arr + arr.map {|a| "test/#{a}"}
end

terms =  ARGV.size > 0 ? ARGV : disp_instruction
mvc_mode = ARGV.include?("-mvc") ? add_test(["controllers","models","views", "backends"]) : []

def get_directory()
  ARGV.select {|arg| File.directory?(arg) }
end

directory = "#{get_directory[0]}**/*" 
terms = terms.select {|term| ![directory, "-mvc"].include?(term) }.map{ |arg| arg.downcase }

def file_open(file, mode)
  File.open(file, mode).read.downcase rescue ""
end

def get_words(terms)
  terms.select{|term| term.start_with?(GREP)}
    .map{|term| term.gsub(GREP,"")}
end

def get_non_words(terms)
  terms.select{|term| !term.start_with?(GREP)}
end

def has_words(terms, text)
  (terms.select{|term| text.include?(term)}.size == terms.size) \
    && (terms.size > 0)
end

def is_term_in_file(file, terms)
  has_words(terms, file_open(file, "r"))
end

def includes(file, terms, words_in_file_name=true, words_in_file_content=true)
  non_terms = get_non_words(terms) 
  terms     = get_words(terms)
  words_in_file_content =
    File.file?(file) && is_term_in_file(file, terms) if terms.size > 0
  words_in_file_name = non_terms.select{ |term|
                         file.downcase.include?(term)
                       }.size == non_terms.size if non_terms.size > 0
  words_in_file_name && words_in_file_content                      
end

def replace(text, terms)
  terms.each { |term| text = text.gsub(term, "#{term.green}") }
  text
end

def has(mvc, file, terms)
  if mvc.size > 0
    name = terms.select{|x| !x.include?("/") && !x.include?(GREP) }[0]
    mvc.map{|x| Regexp.new("#{x}/#{name}*") }.select{|x| x.match(file) }.size > 0
  else
    true
  end
end

def list_files(dir, terms, mvc)
  Dir.glob(dir).select{|file| includes(file, terms) }
    .select{ |file| has(mvc, file, terms) } 
end

def display_matches(f, terms)
  File.open(f, "r").each_with_index do |item, index|
    print replace("#{item}", terms) if  has_words(terms, item) 
  end if File.file?(f)
end

def sort(files, i, new_files=[])
  files = files.flatten 
  [i-1..files.size-1].each {|x| new_files.push(files[x])}
  [0..i-2].each {|x| new_files.push(files[x])}
  new_files.flatten
end

LIST = %w(def concerning belongs_to has_one has_many test)

def paint(t, f)
  puts t.cyan if t.start_with?(LIST[0])
  puts t.blue if t.start_with?(LIST[1])
  (2..4).each do |i|
    puts File.basename(f).gsub(".rb"," ").magenta + t.magenta if t.start_with?(LIST[i])
  end
  puts t.green if t.start_with?(LIST[5])
end

def tmpsearch(f, term, res=[], key="def")
  File.open(f, "r").each do |line|
    return res.map{|x| x.chomp} if (res.size > 0 && line.include?("def "))
    res.push(line) if (line.include?("#{key} "+term) || res.size > 0)
  end
  return res.map{|x| x.chomp }
end

# this part is pretty dirty ( we need to clean this up later)
# this function allows you to enlist function name only in
# the current selected file:
# this allows you to show only functions and Concerns, test labels
# without entering into the file.

def collect_funcs(f, result=[])
  lines = File.open(f, "r").each_line.to_a if File.file?(f)
  result.push cf_subroutine(lines) if lines
  result.flatten.each_slice(5).each_with_index do |lines, i|
    lines.each do |line|
      paint(line.strip, f)
    end
    if i > 0
      print "[q:quit text:code bloc search None:Go next] "
      command = $stdin.gets.chomp.strip
      case command
      when "q"
        abort
      when ""
      else
        tmpsearch(f, command).each do |line|
          puts line.yellow
        end
      end 
    end  
  end
end

def cf_subroutine(lines, new_lines=[])
  lines.each do |line|
    LIST.each {|x| new_lines.push(line) if line.strip.start_with?(x) }
  end
  new_lines.select {|x| x }
end

def get_table_name(res, key)
  res[0].gsub(key, "").gsub("\"","").split(",")[0].strip
end

def parse_value(value)
  value[1..value.size-1].map{|x| x.chomp.gsub("t.","")}
end

def get_command(msg)
  print msg
  $stdin.gets.chomp
end

def check_db(dir, key="create_table ", res=[], hash={})
  File.open(list_files(dir, %w(db schema.rb), [])[0], "r").each do |line|
    if (res.size > 0 && line.include?("end"))
      hash[get_table_name(res, key)] = parse_value(res)
      res = []
    end  
    res.push(line) if (line.include?(key) || res.size > 0)
  end
  command = get_command "[Enter:]"
  case command
  when ""
    hash.keys.each {|k| puts k.red }
  else
    keys   = hash.keys.include?(command) ? [command] : nil
    keys   = hash.keys.select{|k| k.include?(command)} if !keys
    keys  += hash.keys.select{|k| hash[k].select{|v| v.include?(command)}.size > 0 && !keys.include?(k) } 
    keys.each do |key|
      puts "|#{key}|".cyan
      hash[key].tap {|v| puts v.map{|x| x.sub(command, command.cyan)}}
      $stdin.gets.chomp 
    end
  end
end


def execute_files(files, mvc_keyword, terms, dir, i=0)
  key_terms = get_words(terms)
  files.each_with_index do |f, index|
    if (!mvc_keyword || file_open(f, "r").include?(mvc_keyword))
      print "#{replace(f, terms)} ? [v/q/w/p/l/d/#{'t'.magenta}] "
      input = $stdin.gets.chomp.downcase
      check_db(dir)                 if input == "d"
      system "vim #{f}"             if (input == "y" || input == "v")
      display_matches(f, key_terms) if input == "w"
      collect_funcs(f)              if input == "l"
      system "ruby -I test #{f}"    if input == "t"
      execute_files(sort(files, index), mvc_keyword, terms, dir) if input == "p"
      abort                         if input == "q"
    end
  end
end

def search_all(terms, dir, mvc, mvc_keyword)
  execute_files list_files(dir, terms, mvc), mvc_keyword, terms, dir
end

mvc_keyword = terms.select{|x| x.include?(GREP) }[0] 
mvc_keyword = mvc_keyword.gsub(GREP,"") if mvc_keyword 

search_all(terms, directory, mvc_mode, mvc_keyword) 

